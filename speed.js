"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Generated by CoffeeScript 2.5.1
(function () {
  // speed.coffee - A quick rudimentary Javascript speed test utility, written in Coffeescript.
  // Copyright (c) 2014 Dennis Raymondo van der Sluis
  // This program is free software: you can redistribute it and/or modify
  //     it under the terms of the GNU General Public License as published by
  //     the Free Software Foundation, either version 3 of the License, or
  //     (at your option) any later version.
  //     This program is distributed in the hope that it will be useful,
  //     but WITHOUT ANY WARRANTY; without even the implied warranty of
  //     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  //     GNU General Public License for more details.
  //     You should have received a copy of the GNU General Public License
  //     along with this program.  If not, see <http://www.gnu.org/licenses/>
  "use strict";

  var Speed, Types, _, fs, util;

  Types = _ = require('types.js');
  fs = require('fs');
  util = require('util');

  Speed = function () {
    var _align, format, resolveNameFunc, tooMany;

    var Speed = /*#__PURE__*/function () {
      _createClass(Speed, null, [{
        key: "log",
        value: function log() {
          var _console;

          return (_console = console).log.apply(_console, arguments);
        }
      }, {
        key: "run",
        value: function run(callback, calls, rounds, details) {
          var name = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'anonymus';
          var warmup = arguments.length > 5 ? arguments[5] : undefined;
          var average, count, end, i, kickOff, ref, round, start, totalElapsed;

          if (!(callback = _.forceFunction(callback, null))) {
            return Speed.log(name);
          }

          rounds = _.forceNumber(rounds, Speed.rounds);
          calls = _.forceNumber(calls, Speed.calls);
          details = _.forceBoolean(details, Speed.details);

          if (tooMany(rounds * calls)) {
            return;
          }

          if (!warmup) {
            Speed.log(name + ': ' + format(rounds) + ' rounds of ' + format(calls) + ' calls..');
          }

          kickOff = Date.now();

          for (round = i = 1, ref = rounds; 1 <= ref ? i <= ref : i >= ref; round = 1 <= ref ? ++i : --i) {
            count = 0;
            start = Date.now();

            while (count++ < calls) {
              callback();
            }

            end = Date.now();

            if (details && !warmup) {
              Speed.log('round: ' + round + ': ' + _align(end - start + ' ms', 9));
            }
          }

          totalElapsed = Date.now() - kickOff;
          average = format(~~(totalElapsed / rounds));
          totalElapsed = format(totalElapsed);

          if (!warmup) {
            Speed.log('average time for ' + _align(format(calls) + ' calls : ') + _align(average + ' ms', 9));
            Speed.log('total time for   ' + _align(format(calls * rounds) + ' calls : ') + _align(totalElapsed + ' ms', 9));
            return Speed.log();
          }
        }
      }]);

      function Speed(settings) {
        var _this = this;

        _classCallCheck(this, Speed);

        this.add = this.add.bind(this);
        settings = _.forceObject(settings);
        this.rounds = _.forceNumber(settings.rounds, Speed.rounds);
        this.calls = _.forceNumber(settings.calls, Speed.calls);
        this.details = _.forceBoolean(settings.details, Speed.details);
        this.callbacks = {};
        this.callbackCount = 0;

        if (settings.file) {
          this.filename = _.forceString(settings.file, Speed.file);
          this.logFile = fs.createWriteStream(this.filename, {
            flags: 'w'
          });

          Speed.log = function () {
            var _console2;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this.logFile.write(util.format(args + '\n'));

            return (_console2 = console).log.apply(_console2, args);
          };
        }
      }

      _createClass(Speed, [{
        key: "add",
        value: function add(_name, _func) {
          var func, name;

          var _resolveNameFunc = resolveNameFunc(this, _name, _func);

          var _resolveNameFunc2 = _slicedToArray(_resolveNameFunc, 2);

          name = _resolveNameFunc2[0];
          func = _resolveNameFunc2[1];

          if (!this.callbacks[name] && _.isFunction(func)) {
            this.callbacks[name] = func;
          }

          return this;
        }
      }, {
        key: "run",
        value: function run(_name, _func) {
          var callback, name, ref;
          Speed.log('*speed.js* - running ' + this.callbackCount + ' tests..' + '\n');

          if (_.isFunction(_name && !_func)) {
            // this first call with last argument is for warmup round without logging
            Speed.run(func, this.calls, this.rounds, this.details, name, true);
            Speed.run(func, this.calls, this.rounds, this.details, name); // run all tests
          } else {
            Speed.run(callback, this.calls, this.rounds, this.details, name, true);
            ref = this.callbacks;

            for (name in ref) {
              callback = ref[name];
              Speed.run(callback, this.calls, this.rounds, this.details, name);
            }
          }

          if (this.logFile) {
            console.log("done! test results have been saved to:", this.filename, '\n');
          }

          return this;
        }
      }]);

      return Speed;
    }();

    ;

    format = function format(nr) {
      var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;

      var _char = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';

      var formatted, i, index, length, pos, ref;

      if ('' === (nr = _.forceString(nr))) {
        return '';
      }

      length = nr.length - 1;
      formatted = nr[length--];

      if (length < 0) {
        return formatted;
      }

      pos = interval;

      for (index = i = ref = length; ref <= 0 ? i <= 0 : i >= 0; index = ref <= 0 ? ++i : --i) {
        if (--pos % interval === 0) {
          formatted = _char + formatted;
          pos = interval;
        }

        formatted = nr[index] + formatted;
      }

      return formatted;
    };

    _align = function align(string) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
      var aligned, i, n, ref;
      length -= string.length;
      aligned = '';

      if (length > 0) {
        for (n = i = 1, ref = length; 1 <= ref ? i <= ref : i >= ref; n = 1 <= ref ? ++i : --i) {
          aligned += ' ';
        }
      }

      if (_align.right) {
        return aligned + string;
      }

      return string + aligned;
    };

    _align.right = true;

    tooMany = function tooMany(calls) {
      if (calls > Speed.maxCalls) {
        log('You are trying to run more than ' + format(Speed.maxCalls) + ' calls, increase Speed.maxCalls if you really want this.');
        log('Aborting..');
        return true;
      }
    };

    resolveNameFunc = function resolveNameFunc(ctx, name, func) {
      if (_.isFunction(name)) {
        func = name;
        name = 'anonymus';
      }

      name = ++ctx.callbackCount + ': ' + name;
      return [name, func];
    };

    Speed.Types = Types;
    Speed.details = false;
    Speed.rounds = 1;
    Speed.calls = 1;
    Speed.maxCalls = 100000000;
    Speed.file = './speed.log';
    return Speed;
  }.call(this);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Speed;
  } else if (typeof window !== "undefined" && window !== null) {
    window.Speed = Speed;
  }
}).call(void 0);